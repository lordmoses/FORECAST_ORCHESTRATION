# A script to run a folder of malware executables.
# Takes one argument, the folder name (default: samples).
# Any messages created by this script during runtime will be output to IsRunningOutput.txt,
# but any output from the subprocesses themselves get sent directly to stdout.
# Will terminate (if still running) each program and then move them to a subfolder based on their status after an amount of time (5s).
# Each of the possible subfolders:
# running - was running after end time.
# not_running - was not running after end time.
# not_in_tasklist - process status was still running, but filename could not be found in task manager list.
# could_not_run - trying to create the process caused an exception.
# Processes that cannot be killed cannot have their executables moved (this error will be logged), and
# executables that cause some kind of error / exception when launched, but launch succesfully do NOT go in the could_not_run folder.
# There currently exists an issue where programs that create error messages (e.g. dll not found)
# will be marked as running, because they will not terminate until the messagebox is clicked.
# Exceptions caught by windows itself are not subject to this problem.
# Any program that has an open GUI window of any kind when it is being killed will be marked
# in the output log, but this is not possible in cygwin or other environments where windows modules cannot be inported.

# print function for python2
from __future__ import print_function
import os, re, subprocess, sys, threading, time
# windows specific imports, if they are missing try pip install pypiwin32, they will NOT work with cygwin
try:
  import win32api, win32con, win32gui, win32process
  # prevent windows from creating dialog box errors in subprocess
  win32api.SetErrorMode(win32con.SEM_FAILCRITICALERRORS | win32con.SEM_NOOPENFILEERRORBOX | win32con.SEM_NOGPFAULTERRORBOX)
  win32_imported = True
except ImportError:
  win32_imported = False
  print("Could not import win32 modules.")

exe_path = "samples"
if len(sys.argv) == 2:
  exe_path = sys.argv[1]
elif len(sys.argv) > 2:
  print("Invalid arguments.")
  sys.exit(1)
if not os.path.exists(exe_path):
  print("Folder " + exe_path + " does not exist")
  sys.exit(1)
# in s
wait_time = 5
running_dir = os.path.join(exe_path, "running")
not_running_dir = os.path.join(exe_path, "not_running")
not_in_tasklist_dir = os.path.join(exe_path, "not_in_tasklist")
could_not_run_dir = os.path.join(exe_path, "could_not_run")
# this includes the main thread, the max number of spawned processes is max_threads - 1
max_threads = 256
# only files that contain any in this array will be run
exe_filter = ['.exe']
# outfile
print_out = "IsRunningOutput.txt"
# log file handle
log = None

def create_dir(dir_name):
  if not os.path.exists(dir_name):
    os.makedirs(dir_name)

def is_proc_in_tasklist(name):
  # windows only, name can be a pid or an exe name (including .exe extension)
  # may get false positives with pids from the session # column
  if re.search(r"\s" + re.escape(str(name)) + r"\s", os.popen("tasklist /NH").read()):
    return True
  return False

def main_thread_wait():
  # this won't necessarily get the oldest thread, but getting any thread is good enough
  threads = threading.enumerate()
  if len(threads) > 1:
    # wait until thread completes
    if threads[0] is not threading.current_thread():
      threads[0].join()
    else:
      threads[1].join()

def get_open_windows():
  # for each open window, return a tuple containing the starting process, title, and handle
  if not win32_imported:
    return []
  values = []
  def foreach_window(hwnd, param):
    try:
      win_text = win32gui.GetWindowText(hwnd)
      # window visible and can accept input
      if win32gui.IsWindowVisible(hwnd) and win32gui.IsWindowEnabled(hwnd):
        # get the process id (not thread id) and return a handle to it
        p = win32api.OpenProcess(win32con.PROCESS_VM_READ | win32con.PROCESS_QUERY_INFORMATION, False, win32process.GetWindowThreadProcessId(hwnd)[1])
        if p != 0:
          # get the exe that started the process
          values.append((str(os.path.basename(win32process.GetModuleFileNameEx(p, 0))), win_text, hwnd))
          win32api.CloseHandle(p)
    except win32api.error:
      # probably a permissions error
      pass
  win32gui.EnumWindows(foreach_window, 0)
  return values

def move_if_running(proc, file_name):
  # kills if still running and moves to running dir, else moves to not running dir
  # if proc still running, but not in task manager, pur in not in tasklist dir
  old_path = os.path.join(exe_path, file_name)
  # if proc.poll() is None, this means it is still running
  if proc.poll() is None:
    proc_in_tasklist = is_proc_in_tasklist(file_name)
    windows = [win for win in get_open_windows() if win[0] == file_name]
    if windows:
      print(str(windows), file=log, end='\r\n')
    try:
      proc.kill()
    except OSError:
      print("Warning: could not kill " + file_name + ", likely because the process completed.", file=log, end='\r\n')
    try:
      if proc_in_tasklist:
        os.rename(old_path, os.path.join(running_dir, file_name))
      else:
        os.rename(old_path, os.path.join(not_in_tasklist_dir, file_name))
    except OSError:
      print("Warning: could not move " + file_name + ". Proc was running, found in tasklist: " + str(proc_in_tasklist) + ".", file=log, end='\r\n')
  else:
    try:
      os.rename(old_path, os.path.join(not_running_dir, file_name))
    except OSError:
      print("Warning: could not move " + file_name + ". Proc was not running.", file=log, end='\r\n')

with open(print_out, 'w') as log:
  create_dir(running_dir)
  create_dir(not_running_dir)
  create_dir(not_in_tasklist_dir)
  create_dir(could_not_run_dir)
  # get all files, ignore directories
  files = [f for f in os.listdir(exe_path) if any(s in f for s in exe_filter) and
    os.path.isfile(os.path.join(exe_path, f))]
  for f in files:
    # handle when the max thread count has been reached
    while threading.active_count() >= max_threads:
      main_thread_wait()
    try:
      # spawn a new process
      file_path = os.path.join(exe_path, f)
      proc = subprocess.Popen([file_path, "ARG1", "ARG2", "ARG3", "ARG4"])
      # create the thread that checks on the process after a delay
      t = threading.Timer(wait_time, move_if_running, (proc, f))
      t.daemon = False
      t.start()
    except OSError:
      os.rename(file_path, os.path.join(could_not_run_dir, f))
  # wait until all threads complete
  while threading.active_count() > 1:
    main_thread_wait()
